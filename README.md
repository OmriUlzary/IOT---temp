# IOT---temp
Abstract 
In this assignment, we got a dataset that contains the inside and the outside temperature readings from the IOT device in 5 months and we were asked to analyze it. Besides learning about the data and analyzing it, the purpose of the assignment was to learn how to analyze the data we received in several ways and finally to examine what is the most effective way to do this. 
 
In the first section, we read about the background on dataset measurement. 
 
In part 2, we explored the data. Firstly, we import the data from a CSV file to Python. We learned about the shape form of the data structure - the number of rows and columns. Afterward, we calculated statistics values to the “temp” column. 
 
In part 3 we were asked to build statistical functions ourselves, without using "Pandas" and afterward, to compare those functions to functions with "Pandas". 
 
In part 4 of the assignment, we built queries in purpose to learn more about the data we were given to explore. 
 
In part 5, we selected 5 selected questions from Part 4, build for them a plot and display their results with matplotlib on purpose reach further conclusions about the data visually.  
 
 
 
 
 
 
 
 
 
 
 
 
 
METHOD 
in this part of the report, we will present what we did in part 3 and 4 in our assignment. 
In part 3 we were asked to build statistical functions on temperature column ourselves, without using "Pandas" and afterward, to compare those functions to functions with "Pandas". The purpose of this part was to show us how long it takes us to build those functions compare to "Pandas" which we can implement even in just one row. 
We were asked to build an average function. In this function, we used two variables and one "for" loop to calculate the average of the column. In other words, we worked "hard" only to calculate a simple operation. However, when we tried to implement the same thing with "Pandas" it took us only one simple row. Afterward, when we built a standard deviation function, this calculates was even more complicated. We used the average function to find the mean of the column, two variables and one "for" loop to calculate the standard deviation. After that, we used "Pandas" to calculate the same thing, it took us one simple row as well. after calculating those two functions, we can conclude that it's much easier to use "Pandas". 
Our next task was to build a variance function, this function was much easier to build. We used the standard deviation function we built before and just squared it. Using "Pandas" was simple as well. In both methods, it took us only one row. However, building mode function was much complicated. Building mode function without using "Pandas" made us use one dictionary, two variables and two "for" loops. We inserted every temperature to the dictionary, the temperature served as the key of the dictionary and the number of times that the temperature appeared in the column was in each temperature value. After that, we compared each temperature in the dictionary and found the temperature which appears for the most times in the column. Calculating the same function with "Pandas" took us one simple row as well with the help of "mode" function. 
After calculating all those simple statistical functions, we were asked to build "f(x)" function. The output of this function is an array that includes all the temperatures that are smaller than the average and all the normalized temperatures that are bigger than the average. Firstly, the functions should get a sorted array, we used sorted function to sort the temperatures. We used the average and the standard deviation functions for calculating the normalized temperatures. By using "for" loop, for every temperature which was smaller than the average, we inserted this temperature as it is shown to a list we built before. However, for a temperature that was bigger than the average, we inserted the normalized temperature to the same list of the smaller ones. After all that, we received an array that includes temperatures and normalized temperatures. The next step was to multiply every index with the temperature it belongs to and finally to sum all the duplicates operations. We used the "f(x)" functions, two variables and one "for" loop to implement this function. When we finished with creating "f(x)" function, we were asked to build "g(x)" function. "g(x)" is the same function as "f(x)" but just for the temperatures which were taken from the device which installed outside. For this calculating, we used zip function to help us run with "for" loop on two columns, the temperature column and in/out column. By using this loop, we inserted only the temperatures which observed outside to a list. We sorted the list, took the average and the standard deviation we calculated before and we did the same operations as we did with "f(x)". We received an array with the normalized and not normalized temperatures only for those reported outside. Finally, we sum this array and "f(x)" array to get the sums of temperatures 
from both functions. After all those calculations, we found out how complicated it is to implement those functions without using "Pandas". For example, when we wanted to pull out only the temperatures which reported outside, we needed to use "zip" function and one loop (too complicated). However, we could use "Pandas" by finding the places where the temperature has been reported, pull out the right "temp" list and even sort the list by just one simple row! In conclusion, this part of the assignment made us understand how easy, simple and clear it is to use "Pandas" compare to not using it. 
In part 4 of the assignment, we built queries in purpose to learn more about the data we were given to explore. 
Firstly, we were asked to find the "id" which has the maximum temperature in our data. We wrote a condition to get the data frame which includes all details of the maximum temperatures. we pulled out only the "id" column and finally because we were asked to return only a single sample at random, we used the function "sample" in "Pandas" to get only one random "id". After we found the id, we wanted to find out what is the ratio between the temperature measured outside to the temperature measured inside. For this calculating, we built a fraction. In the numerator, we put a condition to pull out only the temperatures measured outside and in the end, we used "count" function to count the numbers of those temperatures measured outside. The denominator was written in the same way as the numerator, only instead of pulling out the temperatures measured outside, we replaced it to the temperatures measured inside. This fraction brought us the ratio of those two types of measured temperatures. Afterward, we checked the same ratio but in the opposite way, the ratio between the temperatures measured inside to the temperatures measured outside, for this calculation we did the same thing we did in the previous query, just instead of putting the inside temperatures in the denominator, we put it in the numerator and the outside temperatures in the denominator. 
We were asked to find the average of the temperatures measured outside and inside. We wrote a condition to get only the right place of the temperatures we wanted to pull out and then, we used "mean" function to get the average to those temperatures. Moreover, we had a task to count the number of times each temperature appears in the data. In order to find those temperatures and the frequency of each of them, we used "groupby" to find all groups of temperatures and then, to count every group with "count" function which finally, it will let us get every temperature and the number of times it appears in the data. 
It wasn't the last time we used "groupby" in our assignment. Afterward, we wanted to find each temperature that was in the data and without duplicates. In order to find it out, we have defined an empty list, we used "for" loop to run on each temperature group with the help of "groupby" we defined before, every name of temperature group inserted to the list we built before and in the end, we returned a list consists all temperatures without duplicates. 
In addition, we were asked to pull out the numbers of rows where the temperature is between 30 to 37. We wrote a condition to pull out only those specific temperatures and we added "count" function to count how many times those temperatures appear in the data. Finally, our last query was to find the 3 most common temperatures in the data. In order to find it out, we used the function "value_counts" which sorts the data from higher to the lower, in our case, it's the number of times the temperature appears in the data. Eventually, we used "head" function to pull out the first rows (3 in our case). 
 
Conclusions 
The conclusions from the assignment begin in Part 2. In this Part, we see the big amount of data collected on temperatures by the IOT tool inside and outside a room. We learn about the number of registers, what is the attributes checked, and statistic data on these temperatures. 
The mean is 35.0539, with a standard deviation of 5.699 and a median of 35. In addition, the range between the lowest and the highest temperatures is 30 degrees difference. The range is relatively low relate the many weather changes that occur in 5 months. 
Graph number 1 shows a sample of the percentage of temperatures (30-37) as a percentage number of appearances of each temperature. 
Graph number 1 (Via Query 8) – 
  
According to the graph, the temperatures are divided uniformly relatively. 
In Part 3 of the assignment, we were asked to implement the statistic calculations are shown in Part 2 using functions. We have found that the results of the functions that actually we used are not as accurate as the functions used by Numpy and Pandas libraries. For example, the function that calculates a standard deviation brought us the result 5.699825337587904 and In Numpy we got 5.699825337585307. The results are very similar and the difference happens because the function we apply using loops and makes certain approximations in each iteration and this the reason for the gap. 
In addition, the Python libraries usually implement the functions in better running time in comparison to the functions we write and take up much less volume in memory. An example of implementing a mode function without the Python libraries in comparison to the same function implemented by Pandas.
 
It can be seen that we used two loops for the function we implemented and creating a dictionary for it while the function that implemented via Pandas does not take up memory volume, implement in better running time, and written in only one line of code. 
In question 5 of this part, we normalized the temperature column data. The function f(x) checked for each temperature if was higher or lower than the average and normalized the temperatures higher than average by Z score. The meaning of this function is to simulate an upper roof for the temperature data and lowering all the statistic calculations we calculated in Part 2. 
g(x) function is the same as f(x) but with filtering of the temperatures measured inside the room. Therefore, g(x) has fewer measurements than f(x). The two lists have a number of different registers, so both cannot be put under the same sigma. f(x) function will require more add operations than g(x). 
In part 4, we went into a more in-depth analysis of the data. The analysis was done using queries that applied with the help of the Pandas Library. 
With the queries results, we were able to reach further conclusions about the data. The following charts will help us learn about the data visually and in an easier way to understand the data. 
Graph Number 2 (Query 2 + 3) - The ratio of the number of temperatures measured outside the room to the number of temperatures measured inside the room. 
 
Graph Number 3 (Query 5) - Box plot for temperatures measured outside the room. 
 
Graph number 2 shows that most of the temperatures were measured outside the room (almost 4 times than inside). Graph number 3 shows that the median and average of the temperatures measured outside the room are very close, indicating the stability of the measured temperatures. In addition, the average and the median are approximately 37 degrees. These data are close to the mean and median measured in Part 2 on all temperatures together. But, the number of samples sampled inside the room is 4 times less than the samples that were taken outside the room, the average decreases quite a bit when adding the temperature samples taken inside the room. The conclusion is that the temperature outside the room is significantly lower than the temperature inside the room. 
Graph Number 4 (Query 6) - Distribution of the appearances of temperatures measured by degrees.
 
According to the graph, we got a normal Bimodal distribution. That is, we got two concentrations of temperatures. The first one is of lower temperatures (about 27 degrees to 33 degrees) and the second concentration is of higher temperatures (about 37 degrees to 42 degrees). From the conclusions we have already concluded on graphs 2 and 3, it can be understood that the first peak (low temperatures) belongs to the temperatures measured inside the room and the second peak (high temperatures) belongs to the temperatures measured outside the room. 
In addition, we can learn that at the edges the appearances number of temperatures is very small and almost 0. This given reinforces the claim that the temperature is relatively stable and ranges mainly in the range of 27 degrees to 42 degrees. 
 
